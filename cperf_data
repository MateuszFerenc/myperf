edit sysctf.conf file and add line kernel... to enable system profiling
nano /etc/sysctl.conf
kernel.perf_event_paranoid = -1


create c file
#######
example:
#include <stdio.h>

void funcA(void){
   printf("A");
}

void funcB(void){
   printf("B");
}

int main(){
   for (int i = 0; i < 100000; i++){
      if (i % 100 == 0)
         funcA();
      if (i % 1000 == 0)
         funcB();
   }
   return 0;
}
#######

compile with gcc -o <output-file-name> <file-name> -g
"-g" flag used to produce debugging information in the operating system's native format

find function in compiled file "perf probe --line <function-name> -x <compiled-file>"
example output for "perf probe --line funcB -x test":
	<funcB@/home/mferenc/Desktop/projects/Perf/cperf/test.c:0>
      0  void funcB(void){
      1     printf("B");
      2  }
      

now in root user mode:
create software event for entering function "perf probe -x <compiled-file> 'function'"
example output for "sudo perf probe -x test 'funcB'":
	Added new event:
  		probe_test:funcB     (on funcB in /home/mferenc/projects/Perf/cperf/test)

	You can now use it in all perf tools, such as:

        perf record -e probe_test:funcB -aR sleep 1
        
create software event for exiting function "perf probe -x <compiled-file> '<function_name_end>=function:<last line number from perf proble --line command>'"
example output for "sudo perf probe -x test 'funcB_end=funcB:2'":
	Added new event:
  		probe_test:funcB_end (on funcB:2 in /home/mferenc/projects/Perf/cperf/test)

	You can now use it in all perf tools, such as:

        perf record -e probe_test:funcB_end -aR sleep 1

simple statiscics "sudo perf stat -e probe_<compiled-file>:<function-name> -e probe_<compiled-file>:<function_name_end> ./<compiled-file>"
	shortened output for "sudo perf stat -e probe_test:funcB -e probe_test:funcB_end ./test":
		Performance counter stats for './test':

               100      probe_test:funcB                                            
               100      probe_test:funcB_end                                        

       0,004462530 seconds time elapsed

       0,004436000 seconds user
       0,000000000 seconds sys

record perf data example:
	sudo perf record -e probe_test:funcB -e probe_test:funcB_end ./test
	.........
	[ perf record: Woken up 1 times to write data ]
	[ perf record: Captured and wrote 0,042 MB perf.data (200 samples) ]
	
get perf samples "sudo perf script"
shortened command output:
	test  6534 [000]  3397.573968:     probe_test:funcB: (562c94bad15e)
    test  6534 [000]  3397.573977: probe_test:funcB_end: (562c94bad170)
    test  6534 [000]  3397.573982:     probe_test:funcB: (562c94bad15e)
    test  6534 [000]  3397.573984: probe_test:funcB_end: (562c94bad170)
    test  6534 [000]  3397.573988:     probe_test:funcB: (562c94bad15e)
    test  6534 [000]  3397.573990: probe_test:funcB_end: (562c94bad170)
    test  6534 [000]  3397.573994:     probe_test:funcB: (562c94bad15e)
    ........
    
############################################################################################################
    
perf commands used before running python sript:
sudo perf probe -x test 'main'			<-- handler just to adjust time of measured tracepoints
perf probe --line "main" -x test
sudo perf probe -x test 'main:5'		<-- set tracepoint at funcB call
sudo perf probe -x test 'funcB%return'		<-- set tracepoint at funcB return
sudo perf record -e probe_test:main_L5 -e probe_test:main -e probe_test:funcB__return ./test

And then:
./pps.py


prepared bash script file run_test0 for automated perf test

run_test0:
#!/bin/bash

main_probe=$(sudo perf probe -x test 'main' 2>&1 | tr -d '\n' | awk '{print $4}')
echo $main_probe
main_l5_probe=$(sudo perf probe -x test 'main:5' 2>&1 | tr -d '\n' | awk '{print $4}')
echo $main_l5_probe
funcb_ret_probe=$(sudo perf probe -x test 'funcB%return' 2>&1 | tr -d '\n' | awk '{print $4}')
echo $funcb_ret_probe

sudo perf record -e $main_probe -e $main_l5_probe -e $funcb_ret_probe ./test >/dev/null

$(source venv/bin/activate)
./pps.py

sudo perf probe -d $main_probe
sudo perf probe -d $main_l5_probe
sudo perf probe -d $funcb_ret_probe

pps.py:
#!/bin/python3

import subprocess
import statistics
import matplotlib.pyplot as plotter
from datetime import datetime
from os.path import join as pjoin
from os import mkdir

def analyze_perf_script():
	result = subprocess.check_output("sudo perf script --ns -F time --reltime", shell=True, text=True)
	lines = result.strip().split("\n")
	
	values = []
	lines = lines[1:]
	for i in range(0, len(lines), 2):
		odd_line = float(lines[i+1].replace(":", "").replace(" ", ""))
		even_line = float(lines[i].replace(":", "").replace(" ", ""))
		diff = float(odd_line - even_line) * 1000000000
		values.append(diff)
		
	_min = round(min(values), 2)
	_max = round(max(values), 2)
	avg = round(statistics.mean(values), 2)
	stdev = round(statistics.stdev(values), 2)
	
	return (_min, _max, avg, stdev, values)
	
if __name__ == "__main__":
	result = analyze_perf_script()
	print(f"Minumum: {result[0]} ns\nMaximum: {result[1]} ns\nAverage: {result[2]} ns\nStandard deviation: {result[3]} ns")
	plotter.plot(result[4], color='r', label='funcB')
	plotter.xlabel('tracepoint no.')
	plotter.ylabel('time [ns]')
	plotter.title('funcB exectution time')
	plotter.legend()
	
	results_dir = "results"
	
	try:
		mkdir(results_dir)
	except FileExistsError:
		pass
	
	now_time = datetime.now()
	
	file_name = f"funcB_plot_{now_time.strftime('%H%M%S_%d%m%y')}.png"
	save_path = pjoin(results_dir, file_name) if results_dir is not None else file_name

	try:
		plotter.savefig(save_path)
	except FileExistsError:
		pass
	
###########################################################
what is that time? ...
deltatime? Yes
other options to measure? in progress
read from file? Yes
measure perf overhead? ...
###########################################################


zmierzyc narzut = pomiar - sleep
what can be measured more
check if perf overhead is scallable (worst)
10k samples
insn per cycle?
